"""
stat_lib

Library containing core classes and functions used in 
ramediesDN, ramediesCH and ramedies_CH_IND.

##############
Dependencies:
1. numpy
2. os
3. scipy
4. init_objs_lib
5. cfg

##############
Classes:
Variant class: class with instances containing information about particular variants

Gene class: class containing score-mutational target distributions as well as 
    the variant information for each gene stratified by annotation.

CH_variant class: class storing information about CH variants in the form of pairs
    of Variant class instances.

VariantCollection class: instances store variant (Variant class) information
    stratified by individuals. Used in ramediesCH and ramedies_CH_IND algorithms

##############
Functions are subdivided into blocks. See the rest of the document for details.

"""

import numpy as np
import init_objs_lib
import cfg
from os import path, remove
from scipy.stats import norm, binom, poisson


###################
##### CLASSES #####
###################

# Class with instances containing information about particular variants
class Variant:
    def __init__(self,
                 mut_id_tuple,
                 var_annot,
                 score,
                 inher,
                 proband_id=None):
        # mut_id_tuple: (chromosome, position, reference allele, alternative allele)
        self.mut_id_tuple = mut_id_tuple
        # Variant annotation: variant annotation as specified in cfg/var_annot_list
        self.var_annot = var_annot
        # Variant score
        self.score = score
        # Inheritance as specified in cfg/inherited_from_dict
        self.inher = inher
        # Name of a VCF file serving as a proband identifier
        self.proband_id = proband_id

    def make_mut_id(self):
        # mut_id: chromosome:reference allele_position_alternative allele
        chrom = self.mut_id_tuple[0]
        ref = self.mut_id_tuple[2]
        pos = self.mut_id_tuple[1]
        alt = self.mut_id_tuple[3]
        mut_id = f"chr{chrom}:{ref}_{pos}_{alt}"
        return mut_id

    def print_info(self):
        # Outputs a string with all attributes of a class instance
        mut_id = self.make_mut_id()
        va = f"{self.var_annot[0]}{self.var_annot[1]}"
        return f"{mut_id}|{va}|{self.score}|{self.inher}|{self.proband_id}"


# Class containing score-mutational target distributions for each gene
#	and each annotation class (coding/intronic and SNP/indel)
# In addition, it is used to store variant information in the form of a list of
#	Variant class instances.
class Gene:
    def __init__(self, score_arr, mut_targ_arr):
        # score_arr: array of scores (CADD or SpliceAI),
        # mut_targ_arr: array of mutational targets with scores
        #	equal or higher than the corresponding score
        # Read from ../data/score_lists_*.gz files
        self.score_arr, self.mut_targ_arr = zip(*sorted(zip(score_arr, mut_targ_arr)))
        self.mut_targ_arr = np.array(self.mut_targ_arr)
        self.gene_mu = self.mut_targ_arr[0]

        # gene_length: length of the score vector.
        # Not related to the length of a given gene
        self.gene_length = len(self.mut_targ_arr)

        # Array of variants from proband VCFs
        # Updated in parse_VCF_lib/parse_variant_input
        self.vars = []

        # List of mutational targets of all variants of a specific type
        self.mu_list = []

    def normalize_mut_targs(self, mut_targ_norm=1.0):
        # Normalize mutational targets so that the mutatinal target of
        # the whole genome would be unit.
        # Normalizations are generated by parse_variant_scores_files function
        # as total_mu_dict dictionary
        self.mut_targ_arr = self.mut_targ_arr / mut_targ_norm
        self.gene_mu = self.mut_targ_arr[0]

    def get_mu_from_score(self, score):
        # Infer a mutational target in a gene corresponding to a given score
        # Uses binary search in a sorted score array
        if self.score_arr[0] >= score:
            return self.mut_targ_arr[0]
        elif self.score_arr[-1] < score:
            return 0.0

        ind_low = 0
        ind_high = self.gene_length - 1
        ind_mid = (ind_high - ind_low) // 2

        while ind_high - ind_low > 1:
            if self.score_arr[ind_mid] == score:
                return self.mut_targ_arr[ind_mid]

            elif self.score_arr[ind_low] == score:
                return self.mut_targ_arr[ind_low]

            elif self.score_arr[ind_high] == score:
                return self.mut_targ_arr[ind_high]

            elif self.score_arr[ind_mid] < score:
                ind_low = ind_mid
                ind_mid = (ind_high + ind_low) // 2

            elif self.score_arr[ind_mid] > score:
                ind_high = ind_mid
                ind_mid = (ind_high + ind_low) // 2

        return self.mut_targ_arr[ind_low]

    def calculate_muttargs_DN(self, sum_values=False):
        # Calculates mutational targets going into the y statistic for a single annotation
        # Used only in the de novo regime
        # mu_list: list of mutational targets, which is then printed into a log file
        self.mu_list = []
        for var in self.vars:
            mu = self.get_mu_from_score(var.score)
            self.mu_list.append((self.gene_mu - mu) / self.gene_mu)

        if sum_values:
            return np.sum(self.mu_list)

        return self.mu_list


##################################################
##### COMPOUND HETEROZYGOTE ANALYSIS CLASSES #####
# The following classes are used only in ramediesCH and ramedies_CH_IND

# Class with instances corresponding to the CH variants
# Individual variants are stored as instances of Variant class
class CH_variant:
    def __init__(self, Variant_obj_tuple, ENS_ID):
        # Variant_obj_tuple: (paternal variant, maternal variant)
        self.var_P = Variant_obj_tuple[0]
        self.var_M = Variant_obj_tuple[1]
        # ENSEMBL ID is stored
        self.ENS_ID = ENS_ID

    # Mutational target of a CH variant
    def muttarg(self, Gene_obj_dict, norm=None):
        # Gene_obj_dict: variant annotation -> ENSEMBL ID -> Gene object
        Gene_obj_P = Gene_obj_dict[self.var_P.var_annot][self.ENS_ID]
        Gene_obj_M = Gene_obj_dict[self.var_M.var_annot][self.ENS_ID]
        mu_P = Gene_obj_P.get_mu_from_score(self.var_P.score)
        mu_M = Gene_obj_M.get_mu_from_score(self.var_M.score)

        if not norm:
            norm = np.max([Gene_obj_P.gene_mu ** 2, Gene_obj_M.gene_mu ** 2])

        # Raw CH mutational target
        self.mu = np.max([mu_P, mu_M])
        # CH mutational target within a gene
        self.mu2 = self.mu ** 2 / norm

        return self.mu2

    # Print CH variant information
    def print_info(self):
        info_P = self.var_P.print_info()
        info_M = self.var_M.print_info()
        return f"{info_P}&{info_M}"


# Class that stores information about individual and CH variants
class VariantCollection:
    def __init__(self, ENS_ID, Gene_obj_dict):
        # Sort the variants by inheritance
        # Uses variants from Gene_obj_dict as inputs
        self.P_vars = {}
        self.M_vars = {}
        for va in init_objs_lib.variant_type_iter():
            if not Gene_obj_dict[va].get(ENS_ID):
                continue

            Gene_obj = Gene_obj_dict[va][ENS_ID]
            for Variant_obj in Gene_obj.vars:
                if Variant_obj.inher == 'P':
                    if not self.P_vars.get(Variant_obj.proband_id):
                        self.P_vars[Variant_obj.proband_id] = []
                    self.P_vars[Variant_obj.proband_id].append(Variant_obj)
                elif Variant_obj.inher == 'M':
                    if not self.M_vars.get(Variant_obj.proband_id):
                        self.M_vars[Variant_obj.proband_id] = []
                    self.M_vars[Variant_obj.proband_id].append(Variant_obj)
        # CH_list: list of CH_variant objects
        # Created by the make_CH_var_list method of this class
        self.CH_list = []
        self.ENS_ID = ENS_ID

    def make_CH_var_list(self, Gene_obj_dict):
        # Finds all CH variants in a specific gene
        # Returns the list of Ch variants with the smallest
        # mutational targets per proband.
        if self.P_vars == {} or self.M_vars == {}:
            return None

        per_proband_CHs = {}
        # For each proband, find all CH variants within a given gene
        for proband_id, Variant_obj_list_P in self.P_vars.items():
            Variant_obj_list_M = self.M_vars.get(proband_id)
            if not Variant_obj_list_M:
                continue

            per_proband_CHs[proband_id] = {}

            for P_var in Variant_obj_list_P:
                for M_var in Variant_obj_list_M:
                    CH = CH_variant((P_var, M_var), self.ENS_ID)
                    mu2_CH = CH.muttarg(Gene_obj_dict)
                    per_proband_CHs[proband_id][mu2_CH] = CH

        for proband_id, CH_dict in per_proband_CHs.items():
            mu2_top = sorted(list(CH_dict.keys()))[0]
            self.CH_list.append(CH_dict[mu2_top])

    def calc_CH_y(self):
        # Calculate the per-cohort y statistic
        y = 0
        for CH_obj in self.CH_list:
            y += 1 - CH_obj.mu2

        self.y = y
        return y


#####################
##### FUNCTIONS #####
#####################

# Count genes in gene_instances
# Produces Bonferroni correction factors for the outputs of ramediesDN and 
#	ramediesCH master scripts
def count_genes(Gene_inst_dict, return_dict=False):
    ENS_ID_dict = {}
    for va in init_objs_lib.variant_type_iter():
        for ENS_ID in Gene_inst_dict[va].keys():
            ENS_ID_dict[ENS_ID] = True
    if return_dict:
        return ENS_ID_dict

    return len(ENS_ID_dict.keys())


#####################
# Variant count block

# A set of functions used to read and write files containing by-annotation 
# 	variant counts. In the default runs of ramediesDN and ramediesCH, the files 
#	will be produced from sets of input VCFs
# In the metadata runs, these files will be used as inputs

# Write by-annotation variant count 
def write_by_annot_varcount(by_annot_varcount_dict, outfile_mask):
    # by_annot_varcount_dict: inheritance ID (specified in cfg.inherited_from_dict) ->
    #	variant annotation -> variant count. Used in ramediesDN
    # outfile_mask: identifier of the output file specified by the user
    #	via the --o option
    outfile_name = f"{outfile_mask}_{cfg.varcount_sums_DN}.txt"

    with open(outfile_name, 'w') as outh:
        outh.write('# De novo mutation count by variant type across cohort\n')
        outh.write("inheritance\tvariant_type\tdenovo_mutation_count\n")
        for inher, var_count_dict in by_annot_varcount_dict.items():
            for var_annot, var_count in by_annot_varcount_dict[inher].items():
                va_str = f"{var_annot[0]}{var_annot[1]}"
                outh.write(f"{inher}\t{va_str}\t{var_count}\n")

    print(f"By-annotation variant counts written to: {outfile_name}")


# Make the by-annotation variant count dictionar (by_annot_varcount_dict)
# by_annot_varcount_dict: inheritance ID (specified in cfg.inherited_from_dict) ->
#	variant annotation -> variant count. Used in ramediesDN
def make_by_annot_varcount_dict(varcount_dict, outfile_mask):
    # varcount_dict: individual ID (file name) -> variant annotation -> # variants
    # outfile_mask: identifier of the output file specified by the user
    by_annot_varcount_dict = {}
    for ind_id, ind_varcount in varcount_dict.items():
        for inher, inher_dict in ind_varcount.items():
            if not by_annot_varcount_dict.get(inher):
                by_annot_varcount_dict[inher] = init_objs_lib.init_varcount_dict()
            for va in cfg.var_annot_list:
                by_annot_varcount_dict[inher][va] += ind_varcount[inher][va]

    write_by_annot_varcount(by_annot_varcount_dict, outfile_mask)
    return by_annot_varcount_dict


# Load variant counts from the output of write_by_annot_varcount
# Updates the by_annot_varcount_dict initiated by the 
#	load_by_annot_varcount_dict function call
def load_varcount_from_file(by_annot_varcount_dict,
                            input_ID,
                            variant_annots,
                            suppress_indels_bool):
    # by_annot_varcount_dict: inheritance ID (specified in cfg.inherited_from_dict) ->
    #	variant annotation -> variant count
    # input_ID: identifier of the input file specified by the user via the --M parameter
    # variant_annots: variant annotations specified by the user via the --variant_annots
    #	parameter of one of the master scripts
    infile_name = f"{input_ID}_{cfg.varcount_sums_DN}.txt"

    # Checking the existence of the input file
    if not path.isfile(infile_name):
        raise AssertionError(f"Variant count file {infile_name} does not exist")

    with open(infile_name, 'r') as inh:
        header = None
        for vc_str in inh:
            if vc_str.startswith('#'):
                continue
            if not header:
                header = vc_str.strip().split()
                continue

            vc_str = vc_str.strip().split()
            # 1st column: inheritance code (cfg.inherited_from_dict)
            inher = vc_str[0]
            # 2nd column: variant annotation (cfg.var_annot_list)
            var_annot = (vc_str[1][0], vc_str[1][1])
            if not var_annot[0] in variant_annots:
                continue
            if suppress_indels_bool and var_annot[1] == 'I':
                continue
            # 3rd column: variant count
            varcount = eval(vc_str[2])
            # by_annot_varcount_dict update
            if not by_annot_varcount_dict.get(inher):
                by_annot_varcount_dict[inher] = init_objs_lib.init_varcount_dict()
            by_annot_varcount_dict[inher][var_annot] += varcount

    print(f"Variant counts from {infile_name} loaded")
    return by_annot_varcount_dict


# Load variant counts from the outputs of write_by_annot_varcount
# Constructs a summary by_annot_varcount_dict from multiple inputs
def load_by_annot_varcount_dict(input_IDs, variant_annots, suppress_indels_bool):
    # input_ID: comma-separated identifiers of the input file specified by the
    #	user via the --M parameter
    # variant_annots: variant annotations specified by the user via the --variant_annots
    # suppress_indels_flag: bool specified by the user
    input_IDs = input_IDs.split(',')
    by_annot_varcount_dict = {}
    for input_ID in input_IDs:
        by_annot_varcount_dict = load_varcount_from_file(by_annot_varcount_dict,
                                                         input_ID,
                                                         variant_annots,
                                                         suppress_indels_bool)

    return by_annot_varcount_dict


# Write the variant count distribution
# Although this distribution is not used in any of the analyses,
#	it may still be informative about the quality of calling in the cohort
def write_varcount_dist(varcount_dict, outfile_mask, var_annots, score_thr_dict, input_directory='<unspecified>'):
    # varcount_dict: individual ID (file name) -> variant annotation -> # variants
    # outfile_mask: identifier of the output file specified by the user
    # var_annots: variant annotations specified by the user via the --variant_annots
    #	parameter of one of the master scripts
    # score_threshold_dict: score thresholds specified by the user

    # Constructing variant count distribution
    # varcount_dist: inheritance -> variant annotation -> variant number
    varcount_dist = {}
    suffix = 'comphet'
    for file_name, inher_dict in varcount_dict.items():
        for inher, va_dict in inher_dict.items():
            if 'DN' in inher:
                suffix = 'denovo'
            for va, var_num in va_dict.items():
                if not varcount_dist.get(inher):
                    varcount_dist[inher] = {va: {} for va in cfg.var_annot_list}
                if not varcount_dist[inher][va].get(var_num):
                    varcount_dist[inher][va][var_num] = 0
                varcount_dist[inher][va][var_num] += 1

    outfile_name = f"{outfile_mask}_{suffix}_{cfg.varcount_mask}.txt"

    # Printing the variant count distribution to the output
    with open(f"{outfile_name}", 'w') as outh:
        outh.write('# Variant count distribution computed from input variant files in '+input_directory+'\n')
        outh.write(f"# variant_annotations:\t{var_annots}\n")
        outh.write(f"# CADD_threshold:\t{score_thr_dict['C']}\n")
        outh.write(f"# SpliceAI_threshold:\t{score_thr_dict['I']}\n")
        outh.write("inheritance\tvariant_type\tvariant_count\tnumber_samples\n")
        for inher, va_dict in varcount_dist.items():
            for va, dist_dict in va_dict.items():
                va_str = f"{va[0]}{va[1]}"
                for var_num in sorted(dist_dict.keys()):
                    freq = dist_dict[var_num]
                    outh.write(f"{inher}\t{va_str}\t{var_num}\t{freq}\n")

    print(f"Variant count distributions written to: {outfile_name}")


#####################
# Mutational target block

# A set of functions used to read and write mutational target files
# In the default runs of ramediesDN and ramediesCH, the files 
#	will be produced from sets of input VCFs
# In the metadata runs, these files will be used as inputs

# Loads mutational targets from a single intermediate output file
# Updates the already initialized gene_instances
# Is called by the load_muttargs_from_filelist function
def load_muttargs_from_file(Gene_inst_dict,
                            input_ID,
                            variant_annots,
                            suppress_indels_bool):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # input_ID: one of the intermediate output IDs specified by the user
    # var_annots: variant annotations specified by the user via the --variant_annots
    #	parameter of one of the master scripts
    # suppress_indels_flag: bool specified by the user
    #	(see --help menus of master scripts for details)

    infile_name = f"{input_ID}_{cfg.muttargs_list_DN_ID}.txt"
    if not path.isfile(infile_name):
        raise AssertionError(f"mutational target file {infile_name} does not exist")

    with open(infile_name, 'r') as inh:
        accepted_vars = 0
        discarded_vars = 0

        header = None
        for mu_str in inh:
            if mu_str.startswith('#'):
                continue
            if not header:
                header = mu_str.strip().split()
                continue

            mu_str = mu_str.strip().split()
            variant_annot_types, ensembl_gene_id, mutational_targets = mu_str[0], mu_str[1], mu_str[2]
            mutational_targets = [eval(i) for i in mutational_targets.split(',')]
            variant_annot_types = (variant_annot_types[0], variant_annot_types[1])

            # Filter by specified annotations
            if not variant_annot_types[0] in variant_annots:
                continue
            if suppress_indels_bool and variant_annot_types[1] == 'I':
                continue
            for mu in mutational_targets:
                # Filter by genes accepted in gene_instances
                if not Gene_inst_dict[variant_annot_types].get(ensembl_gene_id):
                    discarded_vars += 1
                    continue
                # gene_instances update
                Gene_inst_dict[variant_annot_types][ensembl_gene_id].mu_list.append(mu)
                accepted_vars += 1

    print(f"Accepted {accepted_vars} variant targets, {discarded_vars} discarded")
    return Gene_inst_dict


# Iterates over intermediate output file IDs specified by the user
# For each ntermediate output file calls load_muttargs_from_file
# Called if --metadata_run_mode is enabled in ramediesDN and 
#	ramediesCH
def load_muttargs_from_filelist(Gene_inst_dict,
                                input_IDs,
                                variant_annots,
                                suppress_indels_bool):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # input_ID: List of intermediate output IDs specified by the user
    # var_annots: variant annotations specified by the user via the --variant_annots
    #	parameter of one of the master scripts
    # suppress_indels_flag: bool specified by the user
    #	(see --help menus of master scripts for details)

    input_IDs = input_IDs.split(',')
    for input_ID in input_IDs:
        Gene_inst_dict = load_muttargs_from_file(Gene_inst_dict,
                                                 input_ID,
                                                 variant_annots,
                                                 suppress_indels_bool)
    return Gene_inst_dict


# Writes mutational targets that can later be read by 
#	load_muttargs_from_filelist function in the case of 
#	metadata run.
def write_muttargs(Gene_inst_dict, outfile_mask, input_directory="<unspecified>"):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # outfile_mask: identifier of the output file specified by the user
    outfile_name = f"{outfile_mask}_{cfg.muttargs_list_DN_ID}.txt"
    with open(outfile_name, 'w') as outh:
        outh.write('# Mutational targets computed from input variant files located in: '+input_directory+'\n')
        outh.write(f"variant_type\tensembl_gene_id\tper_patient_mutational_targets\n")
        for va, va_Gene_obj_dict in Gene_inst_dict.items():
            for ENS_ID, Gene_obj in va_Gene_obj_dict.items():
                muttarg_list = Gene_obj.calculate_muttargs_DN()
                muttarg_str = ','.join([str(i) for i in muttarg_list])
                if len(muttarg_list) == 0:
                    continue
                outh.write(f"{va[0]}{va[1]}\t{ENS_ID}\t{muttarg_str}\n")

    print(f"Variant mutational targets written to: {outfile_name}")


############################
##### Statistics block #####

# Calculate the y statistics for each ENSEMBL ID
# Called by count_y function
def y_from_mu(gene_mus):
    # gene_mus: ENSEMBL_ID -> array of mutational tergets
    gene_ys = {}
    for ENS_ID, muttarg_arr in gene_mus.items():
        if muttarg_arr == []:
            continue
        if not gene_ys.get(ENS_ID):
            gene_ys[ENS_ID] = 0

        gene_ys[ENS_ID] += np.sum(muttarg_arr)
    # gene_ys: ENSEMBL ID -> y statistic
    return gene_ys


# Calculate the y statistics for each ENSEMBL ID
def count_y(Gene_inst_dict, outfile_mask):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # outfile_mask: identifier of the output file specified by the user
    gene_mus = {}  # gene_mus: ENSEMBL_ID -> array of mutational tergets
    for va, va_Gene_obj_dict in Gene_inst_dict.items():
        for ENS_ID, Gene_obj in va_Gene_obj_dict.items():
            if not gene_mus.get(ENS_ID):
                gene_mus[ENS_ID] = []
            gene_mus[ENS_ID] += Gene_obj.mu_list

    return y_from_mu(gene_mus)  # gene_ys: ENSEMBL ID -> y statistic


# For each ENSEMBL ID, make a list of Variant objects corresponding to variants
#	from the input VCFs
def make_gene_mutdict(Gene_inst_dict):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object

    # gene_mutdict: ensembl_gene_id -> list of Variant instances
    gene_mutdict = {}
    for va, va_Gene_obj_dict in Gene_inst_dict.items():
        for ENS_ID, Gene_obj in va_Gene_obj_dict.items():
            for Variant_obj in Gene_obj.vars:
                if not gene_mutdict.get(ENS_ID):
                    gene_mutdict[ENS_ID] = []
                gene_mutdict[ENS_ID].append(Variant_obj)
    return gene_mutdict


# Calculate the lambda parameter (expected mutation count)
def calc_DN_lambda(varcount_dict, Gene_inst_dict, ENS_ID):
    # varcount_dict: inheritance ID (cfg.inherited_from_dict) ->
    #	variant annotation (cfg.var_annot_list) -> variant count
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # ensembl_gene_id: ENSEMBL ID of the focal gene
    lam = 0
    for va in cfg.var_annot_list:
        if Gene_inst_dict[va].get(ENS_ID):
            # For each annotation, multiply the variant count by the
            #	mutational target.
            lam += varcount_dict["DN"][va] * Gene_inst_dict[va][ENS_ID].gene_mu
    return lam


# Calculate the false diagnosis rate based the expected number of
#	variants and the cohort size.
# Returns the Binomial upper bound specified by cfg.false_diag_rate
# To obtain an estimate of the fraction of incorrect diagnoses,
#	divide the false diagnosis rate by the number of variants
#	occurring in a cohort in a given gene.
def false_diag_rate(lam, N_cohort):
    # lam: expected mutation count, see calc_DN_lambda
    if N_cohort == -1:
        return np.nan

    # Estimate of the Binomial probability
    p = lam / N_cohort
    # True diagnosis rate
    higher_p = 1 - cfg.false_diag_rate
    # Result is the value of Binomial PPF
    return binom.ppf(higher_p, N_cohort, p)


# Calculates the CDF of Irwin-Hall distribution
def IH_CDF(x, n):
    # x: statistic
    # n: Irwin-Hall parameter (number of elements in a sum of 0-1 Uniforms)

    # Setting CDF = 1 to the right of the realm of definition
    if x >= n:
        return 1

    # Setting CDF = 0 to the left of the realm of definition
    elif x <= 0:
        return 0

    # Central Limit theorem gives a good approximation on about n > 8
    if n > cfg.IH_norm_approx_thr:
        return norm.cdf(x, loc=n / 2, scale=np.sqrt(n / 12))

    k = int(x)
    stat = 0
    for i in range(k + 1):
        xmi = x - i
        if xmi == 0:
            continue

        if i == 0:
            log_factorial_i = 0
        else:
            log_factorial_i = np.sum(np.log([j for j in range(1, i + 1)]))
        if n - i == 0:
            log_factorial_nmi = 0
        else:
            log_factorial_nmi = np.sum(np.log([j for j in range(1, (n - i) + 1)]))

        # Using factorial transform here to make the calculations more robust
        log_prod_xmi = n * np.log(x - i)
        val = ((-1) ** i) * np.exp(-log_factorial_i - log_factorial_nmi + log_prod_xmi)
        stat += val
    return stat


# Probability of observing a variant in a cohort
def DN_P(lam):
    # lam: expected mutation count, see calc_DN_lambda
    return 1.0 - np.exp(-lam)


# For a single gene, compute the Irwin-Hall - Poisson recurrence statistic
def process_single_gene(y, lam, s_het_w, N_cohort):
    # y: test statistic, sum of mutational targets of independent variants
    #	within single gene
    # lam: expected mutation count, see calc_DN_lambda
    # s_het_w: s_het based weight with unit mean used in the weighted FDR procedure
    #	See Genovese et al., 2006 for details (https://www.jstor.org/stable/20441304)
    # num_samples: cohort size

    P_dnv = DN_P(lam)
    P_val = 0
    # The "infinite" sum is computed with the first ~1000 values
    for i in range(1, cfg.maxIHval):
        # Irwin-Hall survival function
        P_IH = 1 - IH_CDF(y, i)
        # Very small values may be negative due to computational errors
        if P_IH < 0:
            P_IH = 0

        P_Pois = poisson.pmf(i, lam)
        # Element of the sum
        add_P = P_IH * P_Pois
        # Early stop in case of the added value being small
        #	with respect to the already calculated value
        if P_val != 0 and add_P / P_val < cfg.pval_precision:
            break

        P_val += add_P

    # Probability of an observed mutational pattern given that a single
    #	mutation has been observed. Used in Q-Q plots
    P_cond = P_val / P_dnv

    # Q value of the weighted FDR procedure
    Q_val = P_val / s_het_w

    # Computing the false diagnosis rate
    f_diag_rate = false_diag_rate(lam, N_cohort)

    return [Q_val, P_val, P_cond, P_dnv, lam, f_diag_rate, s_het_w]


# Write an output line containing the calculated values
def generate_output_line(pvalues_array,
                         out_handle,
                         Gene_inst_dict,
                         ensembl_gene_id,
                         ensembl_to_genename,
                         gene_mutdict,
                         first_line=False):
    # pvalues_array: process_single_gene output
    # out_handle: output file object
    # gene_instances:  variant annotation -> ensembl_gene_id -> Gene object
    # ensembl_gene_id: gene ENSEMBL ID
    # ENS2GeneID_dict: a dictionary ensembl_id_dict: ensembl_gene_id -> Gene ID
    #	look in init_objs_lib/make_ENS2GeneID_dict for details
    # gene_mutdict: make_gene_mutdict output. A list of Variant objects
    #	corresponding to variants from the input VCFs
    # first_line: bool for writing the header
    if first_line:
        out_handle.write('# Genes harboring de novo mutations across cohort ranked by Q-value\n')
        out_handle.write('# file_names should include relevant patient identifiers\n')
        out_handle.write('# Variant inheritance is M=maternally-inherited, P=paternally-inherited, and DN=denovo\n')
        out_handle.write('# variant_info is &-delimited values: chromsome:refallele_position_altallele|variant_type|variant_functionality_score|variant_inheritance|file_name\n')
        # Writing a header
        print_arr = ["file_names",
                     "ensembl_gene_id",
                     "gene_name",
                     "Q_val",
                     "P_val",
                     "P_cond",
                     "P_dnv",
                     "poisson_lambda",
                     "false_diag_rate",
                     "s_het_weight",
                     "variant_info"]

        out_handle.write('\t'.join(print_arr) + '\n')
        return None

    if gene_mutdict:
        # In the case of a default run, variant and individual information is
        #	included in the output

        # List of individuals carrying detected mutations in the gene
        ind_list = [Variant_obj.proband_id for Variant_obj in gene_mutdict[ensembl_gene_id]]
        ind_list = ','.join(ind_list)
        # List of variant information
        var_info_list = [Variant_obj.print_info() for Variant_obj in gene_mutdict[ensembl_gene_id]]
        var_info_list = ','.join(var_info_list)
    else:
        # In case of metadata run, variant and individual information is not printed
        ind_list = "."
        var_info_list = '.'

    Gene_ID = ensembl_to_genename[ensembl_gene_id]

    # Printning output as a tab-separated list join
    print_arr = [ind_list,
                 ensembl_gene_id,
                 Gene_ID,
                 str(pvalues_array[0]),
                 str(pvalues_array[1]),
                 str(pvalues_array[2]),
                 str(pvalues_array[3]),
                 str(pvalues_array[4]),
                 str(pvalues_array[5]),
                 str(pvalues_array[6]),
                 var_info_list]

    out_handle.write('\t'.join(print_arr) + '\n')


# Benjamini-Hochberg algorithm on Q-values of weighted FDR
# See Genovese et al., 2006 for details (https://www.jstor.org/stable/20441304)
def wFDR(Q_arr, FDR_arr, N_genes):
    # Q_arr: array of Q-values
    # FDR_arr: array of FDR values
    # num_genes: Number of processed genes
    Q_arr = sorted(Q_arr)
    l_Q_arr = len(Q_arr)
    # FDR_thr_dict: FDR -> Q threshold
    FDR_thr_dict = {FDR: 0 for FDR in FDR_arr}
    # For each FDR, computing the threshold Q-value
    for i in range(l_Q_arr):
        for FDR in FDR_arr:
            thr = FDR * (i + 1) / N_genes
            if Q_arr[i] < thr:
                FDR_thr_dict[FDR] = thr
    return FDR_thr_dict


# Write an intermediate output file, perform weighted FDR
#	on the computed P-values
def FDR_procedure(outfile_mask, FDR_arr, N_genes):
    # outfile_mask: identifier of output files specified by the user
    # FDR_arr: array of FDR thresholds (specified by user)
    # num_genes: Number of processed genes

    # outfile_dict: Q_value -> output string. Used to produce
    #	sorted output
    outfile_dict = {}

    # Q_val_arr: list of Q-values
    Q_val_arr = []

    filename = f"{outfile_mask}_{cfg.DN_result}_tmp.txt"

    with open(filename, 'r') as inh:
        header = None
        for output_str in inh:
            if output_str.startswith('#'):
                continue
            if not header:
                header = {k: i for i, k in enumerate(output_str.strip().split())}
                header_line = output_str.strip().split()
                continue

            output_str = output_str.strip().split('\t')
            Q_val = eval(output_str[header["Q_val"]])
            Q_val_arr.append(Q_val)
            if not outfile_dict.get(Q_val):
                outfile_dict[Q_val] = []
            outfile_dict[Q_val].append(output_str)

    FDR_thr_dict = wFDR(Q_val_arr, FDR_arr, N_genes)
    FDR_header = '\t'.join([f"FDR_{p}" for p in FDR_arr])

    # Final output file
    filename = f"{outfile_mask}_{cfg.DN_result}.txt"
    with open(filename, 'w') as outh:
        hs = '\t'.join(header_line)
        # Header with the FDR values is concatenated with the
        #	existing header
        outh.write(f"{hs}\t{FDR_header}\n")
        for Q_val in sorted(outfile_dict.keys()):
            FDR_res_arr = []
            # Using Q-value thresholds from wFDR
            for FDR in FDR_arr:
                # FDR pass/ not pass is added to the output
                if Q_val < FDR_thr_dict[FDR]:
                    FDR_res_arr.append("True")
                else:
                    FDR_res_arr.append("False")
            FDR_res = '\t'.join(FDR_res_arr)
            for file_str_arr in outfile_dict[Q_val]:
                fsa = '\t'.join(file_str_arr)
                outh.write(f"{fsa}\t{FDR_res}\n")

    print(f"Results written to {filename}")


# Master function of ramediesDN
# Based on the variant information or supplied metadata, calculates
#	the ramediesDN P-value, performs a weighted FDR with weights 
#	corresponding to 10 s_het bins and prints the output
def calc_DN_stat(ENS_ID_y_dict,
                 varcount_dict,
                 Gene_inst_dict,
                 outfile_mask,
                 N_cohort,
                 gene_mutdict,
                 FDR_str,
                 N_genes):
    # ENS_ID_y_dict: Gene ENSEMBL ID -> y statistic, count_y output,
    #	computed in ramediesDN.py code
    # varcount_dict: # varcount_dict: inheritance ID (cfg.inherited_from_dict) ->
    #	variant annotation (cfg.var_annot_list) -> variant count
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # outfile_mask: identifier of output files specified by the user
    # num_samples: cohort size
    # gene_mutdict: make_gene_mutdict output. A list of Variant objects
    #	corresponding to variants from the input VCFs
    # FDR_str: comma-separated list of FDR thresholds (specified by user)
    # num_genes: Number of processed genes

    # FDR values are obtained from the input string
    FDR_arr = [eval(i) for i in FDR_str.split(',')]

    # s_het_bins: Gene ENSEMBL ID -> s_het enrichment bin
    # Enrichment values are the proportions of exclusively dominant OMIM genes
    #	in s_het deciles
    s_het_bins = init_objs_lib.load_s_het_bins()

    # ENS2GeneID_dict: ensembl_gene_id -> Gene ID
    ENS2GeneID_dict = init_objs_lib.make_ENS2GeneID_dict()

    # Intermediate output file
    filename = f"{outfile_mask}_{cfg.DN_result}_tmp.txt"

    with open(filename, 'w') as outh:
        # Header is printed
        generate_output_line(pvalues_array=None,
                             out_handle=outh,
                             Gene_inst_dict=Gene_inst_dict,
                             ensembl_gene_id=None,
                             ensembl_to_genename=ENS2GeneID_dict,
                             gene_mutdict=gene_mutdict,
                             first_line=True)
        # Iterating over genes
        for ENS_ID, y in ENS_ID_y_dict.items():
            # Expected number of variant calculated
            lam = calc_DN_lambda(varcount_dict, Gene_inst_dict, ENS_ID)
            # s_het weight is obtained
            s_het_w = s_het_bins.get(ENS_ID)
            # For gene with no s_het values, s_het weight is set to unity
            if not s_het_w:
                s_het_w = 1.0

            # Calculating the probabilities and Q values
            # See process_single_gene for details
            P_arr = process_single_gene(y, lam, s_het_w, N_cohort)

            # Intermediate output is printed
            generate_output_line(P_arr,
                                 outh,
                                 Gene_inst_dict,
                                 ENS_ID,
                                 ENS2GeneID_dict,
                                 gene_mutdict,
                                 first_line=False)
    # Weighted FDR step
    FDR_procedure(outfile_mask, FDR_arr, N_genes)
    # Remove the intermediate output
    remove(filename)


###############################
##### CH statistics block #####

# The following functions are used only in ramediesCH and ramediesCH_IND
#	algorithms


##### Mutation number product block
# Set of functions dealing with the products of mutation counts between
#	annotations. These products are used to compute the expected counts 
#	of CH variants denoted as lambda (a.k.a the Poisson parameter lambda)
#	or "lam" as here, as lambda is a Python default function

# Write the mutation number products to intermediate output files
def write_mutnum_prods(mutnum_prod_dict,
                       mutnum_prod_dist_dict,
                       outfile_mask,
                       consequence_list,
                       input_directory="<unspecified>"):
    # mutnum_prod_dict: pair of variant annotations (specified in
    #	cfg.var_annot_list) -> sum of the products of their counts
    #	across individuals. See mutnum_prod for details.
    # mutnum_prod_dist_dict: pair of variant annotations ->
    #	product value -> frequency. Used for shallow QC purposes
    # outfile_mask: identifier of output files specified by the user
    # consequence_list: variant consequence codes specified by the user.
    #	'C' for coding, 'I' for intronic

    filename = f"{outfile_mask}_{cfg.mutnum_prod_CH}.txt"

    # Writing the mutation products to the intermediate output
    with open(filename, 'w') as outh:
        outh.write("# Sum (across cohort) of all products of (# paternally-inherited variants)x(# maternally-inherited variants) for each variant type pair\n")
        outh.write('# Variant input files processed from: '+input_directory+'\n')
        outh.write("paternal_variant_type\tmaternal_variant_type\ttotal_product_of_variant_counts\n")
        for annot_pair, count in mutnum_prod_dict.items():
            annot_P = f"{annot_pair[0][0]}{annot_pair[0][1]}"
            annot_M = f"{annot_pair[1][0]}{annot_pair[1][1]}"
            outh.write(f"{annot_P}\t{annot_M}\t{count}\n")

    print(f"Variant count products written to {filename}")

    filename = f"{outfile_mask}_{cfg.mutnum_prod_dist_CH}.txt"

    # Writing the distribution of mutation products to the
    #	intermediate output
    with open(filename, 'w') as outh:
        outh.write('# Number of input variant files with specific (paternal_variant_count)x(maternal_variant_count) values\n')
        outh.write('# Variant input files processed from: '+input_directory+'\n')
        outh.write("paternal_variant_type\tmaternal_variant_type\tproduct_of_variant_counts\tnumber_samples\n")
        for annot_pair, dist_dict in mutnum_prod_dist_dict.items():
            annot_P = f"{annot_pair[0][0]}{annot_pair[0][1]}"
            annot_M = f"{annot_pair[1][0]}{annot_pair[1][1]}"
            for mnp in sorted(dist_dict.keys()):
                freq = dist_dict[mnp]
                outh.write(f"{annot_P}\t{annot_M}\t{mnp}\t{freq}\n")

    print(f"Distributions of variant count products written to {filename}")


# Calculate the sum of products of mutation counts between
#	annotations. By calling write_mutnum_prods, writes the mutation 
#	products along with  the distribution of mutation products 
#	to the intermediate output
def mutnum_prod(varcount_dict, outfile_mask, consequence_list, input_directory="<unspecified>"):
    # varcount_dict: proband_id -> inheritance -> variant annotation ->
    #	variant count
    # outfile_mask: identifier of output files specified by the user
    # consequence_list: variant consequence codes specified by the user.
    #	'C' for coding, 'I' for intronic

    # mutnum_prod_dict: pair of variant annotations (specified in
    #	cfg.var_annot_list) -> sum of the products of their counts
    mutnum_prod_dict = {}

    # mutnum_prod_dist_dict: pair of variant annotations ->
    #	product value -> frequency. Used for shallow QC purposes
    mutnum_prod_dist_dict = {}

    # Initiating the double variant count dictionaries
    # cfg.var_annot_list: list of variant annotations
    # 	1st letter: 'C' for coding, 'I' for intronic
    # 	2nd letter: 'S' for SNP, 'I' for indel
    for va1 in cfg.var_annot_list:
        for va2 in cfg.var_annot_list:
            mutnum_prod_dict[(va1, va2)] = 0
            mutnum_prod_dist_dict[(va1, va2)] = {}

    # Iterating over individuals, summing the mutation count
    #	products
    for proband_id, inher_dict in varcount_dict.items():
        if not inher_dict.get('M') or not inher_dict.get('P'):
            continue

        # Iterating over the pairs of annotations
        for annot_pair in mutnum_prod_dict.keys():
            va_P = annot_pair[0]
            va_M = annot_pair[1]
            mnp = inher_dict['P'][va_P] * inher_dict['M'][va_M]
            mutnum_prod_dict[(va_P, va_M)] += mnp
            if not mutnum_prod_dist_dict[(va_P, va_M)].get(mnp):
                mutnum_prod_dist_dict[(va_P, va_M)][mnp] = 0
            mutnum_prod_dist_dict[(va_P, va_M)][mnp] += 1

    # Writing intermediate outputs, which are used in the metadata runs
    write_mutnum_prods(mutnum_prod_dict,
                       mutnum_prod_dist_dict,
                       outfile_mask,
                       consequence_list,
					   input_directory)

    return mutnum_prod_dict


# In the case of ramediesCH metadata run, the mutation number
#	products are read from the intermediate output files written
#	by the write_mutnum_prods function
# This function is called in read_mutnum_prods and processes a single file
def read_mutnum_prods_from_file(file_id,
                                mutnum_prod_dict,
                                variant_annots,
                                suppress_indels_bool):
    # file_id: intermediate output identifier specified by user through
    #	the --M parameter
    # mutnum_prod_dict: pair of variant annotations (specified in
    #	cfg.var_annot_list) -> sum of the products of their counts.
    #	Initiated in read_mutnum_prods and updated here
    # variant_annots: variant annotation specified by the user as
    #	--variant_annots parameter of ramediesCH
    # suppress_indels_flag: specified by the user if the indels are
    #	not to be processed.

    filename = f"{file_id}_{cfg.mutnum_prod_CH}.txt"
    with open(filename, 'r') as inh:
        for mnp_str in inh:
            header = None
            if mnp_str.startswith('#'):
                continue
            if not header:
                header = mnp_str.strip().split()
                continue

            mnp_str = mnp_str.strip().split()
            # Paternal variant annotation
            va_P = (mnp_str[0][0], mnp_str[0][1])
            # Maternal variant annotation
            va_M = (mnp_str[1][0], mnp_str[1][1])
            # Check if the line meets run specifications
            # Specified annotation
            if va_P[0] not in variant_annots or va_M[0] not in variant_annots:
                continue
            # Specified regime of indel processing
            if suppress_indels_bool and (va_P[1] == 'I' or va_M[1] == 'I'):
                continue
            count = eval(mnp_str[2])
            mutnum_prod_dict[(va_P, va_M)] += count

    return mutnum_prod_dict


# Process the variant number product files with IDs specified by the user 
#	under --M parameter of ramediesCH
def read_mutnum_prods(file_id_list, variant_annots, suppress_indels_bool):
    # file_id_list: comma-separated list of intermediate output identifiers
    #	specified by user through the --M parameter
    # variant_annots: variant annotation specified by the user as
    #	--variant_annots parameter of ramediesCH
    # suppress_indels_flag: specified by the user if the indels are
    #	not to be processed.

    # mutnum_prod_dict: pair of variant annotations (specified in
    #	cfg.var_annot_list) -> sum of the products of their counts
    mutnum_prod_dict = {}

    # Initiating the double variant count dictionaries
    # cfg.var_annot_list: list of variant annotations
    # 	1st letter: 'C' for coding, 'I' for intronic
    # 	2nd letter: 'S' for SNP, 'I' for indel
    for va1 in cfg.var_annot_list:
        for va2 in cfg.var_annot_list:
            mutnum_prod_dict[(va1, va2)] = 0

    for file_id in file_id_list.split(','):
        # For each pecified ID, call read_mutnum_prods_from_file
        mutnum_prod_dict = read_mutnum_prods_from_file(file_id,
                                                       mutnum_prod_dict,
                                                       variant_annots,
                                                       suppress_indels_bool)

    return mutnum_prod_dict


##### CH mutational target block

# Set of functions dealing with the products of mutational targets of individual 
#	variants between annotations. These are used to compute the y statistic 
#	of CH variants.

# Write the CH variant mutational targets defined as the maximum of
#	individual (paternally or maternally inherited) variant mutational targets
# The intermediate output produced by this function is read by read_CH_muttargs and
#	read_CH_muttargs_from_file in the case of metadata run
def write_CH_muttargs(CH_dict, outfile_mask, indirectory="<unspecified>"):
    # CH_dict: an object analogous to gene_mutdict object used in ramediesDN.
    #	ENSEMBL_ID -> list of CH_variant objects.
    # outfile_mask: identifier of output files specified by the user
    filename = f"{outfile_mask}_{cfg.muttargs_CH_ID}.txt"
    with open(filename, 'w') as outh:
        outh.write(
            '# Compound heterozygous mutational targets computed for processed variant files in ' + indirectory + '\n')
        outh.write('# variant types are in the format paternal_variant_type,maternal_variant_type\n')
        outh.write(f"variant_type\tensembl_gene_id\tper_patient_mutational_targets\n")
        for ENS_ID, VariantCollection_obj in CH_dict.items():
            for CH_variant_obj in VariantCollection_obj.CH_list:
                # va_P: variant annotation of the paternally inherited variant
                # va_M: variant annotation of the maternally inherited variant
                va_P = CH_variant_obj.var_P.var_annot
                va_M = CH_variant_obj.var_M.var_annot
                # CH annotation
                va = f"{va_P[0]}{va_P[1]},{va_M[0]}{va_M[1]}"
                # CH mutational target
                muttarg = CH_variant_obj.mu2
                outh.write(f"{va}\t{ENS_ID}\t{muttarg}\n")

    print(f"Compound heterozygous variant mutational targets written to: {filename}")


# In the case of metadata run, read the CH mutational targets
#	from a file produced by write_CH_muttargs
# Called in read_CH_muttargs
def read_CH_muttargs_from_file(file_id,
                               CH_y_dict,
                               variant_annots,
                               suppress_indels_bool):
    # file_id: intermediate output identifier specified by user through
    #	the --M parameter
    # CH_y_dict: akin to the ENS_ID_y_dict of ramediesDN. Gene ENSEMBL ID ->
    #	y statistic. Initialized in read_CH_muttargs, updated here
    # variant_annots: variant annotation specified by the user as
    #	--variant_annots parameter of ramediesCH
    # suppress_indels_flag: specified by the user if the indels are
    #	not to be processed.

    filename = f"{file_id}_{cfg.muttargs_CH_ID}.txt"
    print("Reading compound heterozygous mutational targets from file:", filename)
    with open(filename, 'r') as inh:
        header = None
        for mt_line in inh:
            if mt_line.startswith('#'):
                continue
            if not header:
                header = mt_line.strip().split()
                continue

            mt_line = mt_line.strip().split()
            variant_type = mt_line[0].split(',')
            ensembl_gene_id = mt_line[1]
            mutational_targets = [eval(i) for i in mt_line[2].split(',')]

            # only consider the variant types (coding/intronic) that are specified:
            if variant_type[0][0] not in variant_annots or variant_type[1][0] not in variant_annots:
                continue
            if suppress_indels_bool and (variant_type[0][1] == 'I' or variant_type[1][1] == 'I'):
                continue

            if not CH_y_dict.get(ensembl_gene_id):
                CH_y_dict[ensembl_gene_id] = 0

            for muttarg in mutational_targets:
                CH_y_dict[ensembl_gene_id] += 1 - muttarg

    return CH_y_dict


# In the case of metadata run, read the CH mutational targets
#	from a list of files produced by write_CH_muttargs in default or
#	metadata write mode runs
def read_CH_muttargs(file_id_list, variant_annots, suppress_indels_bool):
    # file_id_list: comma-separated list of intermediate output identifiers
    #	specified by user through the --M parameter
    # variant_annots: variant annotation specified by the user as
    #	--variant_annots parameter of ramediesCH
    # suppress_indels_flag: specified by the user if the indels are
    #	not to be processed.

    # CH_y_dict: akin to the ENS_ID_y_dict of ramediesDN. Gene ENSEMBL ID ->
    #	y statistic
    CH_y_dict = {}

    for file_id in file_id_list.split(','):
        CH_y_dict = read_CH_muttargs_from_file(file_id,
                                               CH_y_dict,
                                               variant_annots,
                                               suppress_indels_bool)

    return CH_y_dict


##### CH statistics block
# A set of functions used in the ramediesCH core algorithm

# Calculate the expected number of CH variants given the gene and 
#	the cohort size.
def calc_CH_lambda(mutnum_prod_dict, Gene_inst_dict, ENS_ID):
    # mutnum_prod_dict: mutnum_prod or read_mutnum_prods output
    #	CH variant annotation -> count
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # ensembl_gene_id: Gene ENSEMBL ID
    CH_lambda = 0
    for (va_P, va_M), count in mutnum_prod_dict.items():
        if not Gene_inst_dict[va_P].get(ENS_ID) or not Gene_inst_dict[va_M].get(ENS_ID):
            continue
        mu_P = Gene_inst_dict[va_P][ENS_ID].gene_mu
        mu_M = Gene_inst_dict[va_M][ENS_ID].gene_mu
        # The expected number is updated based on the gene mutational targets
        #	and the products of mutation counts
        CH_lambda += count * mu_P * mu_M

    return CH_lambda


# CH_y_dict: obtained in read_CH_muttargs_from_file in the case of metadata run,
#	Calculated here in the regular run
def calc_CH_y_dict(CH_dict):
    # CH_dict: ensembl_gene_id -> VariantCollection object

    # CH_y_dict: Gene ENSEMBL ID -> y statistic
    CH_y_dict = {}
    for ENS_ID, VariantCollection_obj in CH_dict.items():
        if VariantCollection_obj.CH_list == []:
            continue

        # For each gene, y is calculated
        y = VariantCollection_obj.calc_CH_y()
        CH_y_dict[ENS_ID] = y

    return CH_y_dict


# Analogous to ramediesDN generate_output_line.
# Generates an output line for ramediesCH
def generate_output_line_CH(P_arr,
                            outh,
                            CH_dict,
                            ENS_ID,
                            ENS2GeneID_dict,
                            first_line):
    # pvalues_array: truncated process_single_gene output (without s_het bins and
    #	weighted FDR Q-values)
    # out_handle: output file object
    # CH_dict: ensembl_gene_id -> VariantCollection object
    # ensembl_gene_id: gene ENSEMBL ID
    # ENS2GeneID_dict: a dictionary ensembl_id_dict: ensembl_gene_id -> Gene ID
    #	look in init_objs_lib/make_ENS2GeneID_dict for details
    # first_line: bool for writing the header

    if first_line:
        # Prints the first line
        print_arr = ["file_names",
                     "ensembl_gene_id",
                     "gene_name",
                     "P_val",
                     "P_cond",
                     "P_comphet",
                     "poisson_lambda",
                     "false_diagnosis_rate",
                     "variant_info"]

        outh.write('\t'.join(print_arr) + '\n')
        return None

    if CH_dict:
        # In case of default run, the individual information is printed to the output
        #	along with the variant information

        # IDs of individuals are printed
        ind_list = [CH.var_P.proband_id for CH in CH_dict[ENS_ID].CH_list]
        ind_list = ','.join(ind_list)
        # Variant information is printed
        var_info_list = [CH.print_info() for CH in CH_dict[ENS_ID].CH_list]
        var_info_list = ','.join(var_info_list)
    else:
        # In the case of metadata run, variant information and individual IDs
        #	are not printed to the output
        ind_list = "."
        var_info_list = '.'

    Gene_ID = ENS2GeneID_dict[ENS_ID]

    print_arr = [ind_list,
                 ENS_ID,
                 Gene_ID,
                 str(P_arr[0]),
                 str(P_arr[1]),
                 str(P_arr[2]),
                 str(P_arr[3]),
                 str(P_arr[4]),
                 var_info_list]

    return '\t'.join(print_arr) + '\n'


# Master function of ramediesCH
# Based on the variant information or supplied metadata, calculates
#	the ramediesCH P-values and prints the output
def calc_CH_stat(CH_y_dict,
                 CH_dict,
                 Gene_inst_dict,
                 mutnum_prod_dict,
                 outfile_mask,
                 N_cohort,
                 N_genes):
    # CH_y_dict: Gene ENSEMBL ID -> y statistic
    # CH_dict: ensembl_gene_id -> VariantCollection object
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # mutnum_prod_dict: mutnum_prod or read_mutnum_prods output
    #	CH variant annotation -> count
    # outfile_mask: identifier of output files specified by the user
    # num_samples: cohort size
    # num_genes: Number of processed genes

    # ENS2GeneID_dict: ENSEMBL ID -> Gene ID
    ENS2GeneID_dict = init_objs_lib.make_ENS2GeneID_dict()

    # Output file
    filename = f"{outfile_mask}_{cfg.CH_result}.txt"

    # P-value -> list of output lines. Used to make a sorted output file
    output_dict = {}

    with open(filename, 'w') as outh:
        # Printing the output header
        generate_output_line_CH(P_arr=None,
                                outh=outh,
                                CH_dict=CH_dict,
                                ENS_ID=None,
                                ENS2GeneID_dict=ENS2GeneID_dict,
                                first_line=True)

        # For each gene, calculate statistic and put the output line into
        #	output_dict
        for ENS_ID, y in CH_y_dict.items():
            lam = calc_CH_lambda(mutnum_prod_dict, Gene_inst_dict, ENS_ID)
            P_arr = process_single_gene(y,
                                        lam,
                                        s_het_w=1.0,  # Dummy value
                                        N_cohort=N_cohort)[1:-1]  # Discarding Q and s_het

            ol = generate_output_line_CH(P_arr,
                                         outh,
                                         CH_dict,
                                         ENS_ID,
                                         ENS2GeneID_dict,
                                         first_line=False)

            if not output_dict.get(P_arr[0]):
                output_dict[P_arr[0]] = []
            output_dict[P_arr[0]].append(ol)

        # Writing the otput data
        for P in sorted(output_dict.keys()):
            for ol in output_dict[P]:
                outh.write(ol)

    print(f"Results written to {filename}")


##################################
##### By-individual CH block #####

# A set of functions used exclusively in the ramediesCH_IND algorithm
#	dealing with individual-level CH analysis.

# Function that deletes all the variant information from the existing 
#	gene_instances.
# Used to re-use the initially built gene_instances multiple times
def clean_Gene_inst_dict(Gene_inst_dict):
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    for va in Gene_inst_dict.keys():
        for ENS_ID in Gene_inst_dict[va].keys():
            # vars and mu_list attributes are cleaned
            Gene_inst_dict[va][ENS_ID].vars = []
            Gene_inst_dict[va][ENS_ID].mu_list = []
    return Gene_inst_dict


# Calculate the expected number of per-individual CH variants
def calc_CH_IND_P(y, CH_lambda):
    # y: per-individual CH test statistic, which is the fraction
    #	of CH mutational targets across the genome equal or lower
    #	to the observed one.
    P_val = 0
    stat_val = 1
    K_i = 1
    # Infinite sum approximation
    while stat_val > 1e-16 or K_i < 5 * CH_lambda or K_i < 10:
        stat_val = (1 - (1 - y) ** K_i) * poisson.pmf(K_i, CH_lambda)
        P_val += stat_val
        K_i += 1
    # Probability of y conditional on observation of at least one CH
    P_cond = P_val / (1 - np.exp(-CH_lambda))
    return [P_val, P_cond, y, CH_lambda]


# Print output lines
def print_CH_IND_line(outh,
                      P_arr=None,
                      top_CH=None,
                      ENS_ID=None,
                      ENS2GeneID_dict=None,
                      first_line=True):
    # out_handle: output file object
    # pvalues_array: calc_CH_IND_P output
    # top_CH: CH_variant object corresponding to the lest observed CH
    # ensembl_gene_id: gene ENSEMBL ID
    # ENS2GeneID_dict: a dictionary ensembl_id_dict: ensembl_gene_id -> Gene ID
    #	look in init_objs_lib/make_ENS2GeneID_dict for details
    # first_line: bool for writing the header

    # Print the output header
    if first_line:
        print_arr = ["file_name",
                     "ensembl_gene_id",
                     "gene_name",
                     "P_val",
                     "P_cond",
                     "y_stat",
                     "poisson_lambda",
                     "variant_info"]

        outh.write('\t'.join(print_arr) + '\n')
        return None

    # Print the output for a single individual
    Gene_ID = ENS2GeneID_dict[ENS_ID]
    var_info = top_CH.print_info()
    print_arr = [top_CH.var_P.proband_id,
                 ENS_ID,
                 Gene_ID,
                 str(P_arr[0]),
                 str(P_arr[1]),
                 str(P_arr[2]),
                 str(P_arr[3]),
                 var_info]

    outh.write('\t'.join(print_arr) + '\n')


# Master function of ramediesCH_IND
# Based on the variant information from a single individual, calculates
#	the ramediesCH_IND P-values and prints the output
def calc_CH_IND_stat(outh,
                     varcounts,
                     top_CH,
                     Gene_inst_dict,
                     ENS2GeneID_dict):
    # out_handle: output file object
    # varcounts: inheritance ID (specified in cfg.inherited_from_dict) ->
    #	variant annotation (specified in cfg.var_annot_list) ->
    #	Number of per-individual variants
    # top_CH: CH_variant object corresponding to the lest observed CH
    # gene_instances: variant annotation -> ensembl_gene_id -> Gene object
    # ENS2GeneID_dict: a dictionary ensembl_id_dict: ensembl_gene_id -> Gene ID
    #	look in init_objs_lib/make_ENS2GeneID_dict for details

    # The expected number of Ch variants per individual
    CH_lambda = 0

    # y: per-individual CH test statistic, which is the fraction
    #	of CH mutational targets across the genome equal or lower
    #	to the observed one.
    y = 0

    # corr_factor: maximal CH mutational target in the sense of y
    corr_factor = 0

    # Observed mutational target
    mu2 = top_CH.mu ** 2

    # Iterate over pairs of variant annotations
    for va_P, var_num_P in varcounts['P'].items():
        for va_M, var_num_M in varcounts['M'].items():
            if var_num_P * var_num_M == 0:
                continue

            # Iterate over genes
            for ENS_ID, Gene_obj_P in Gene_inst_dict[va_P].items():
                Gene_obj_M = Gene_inst_dict[va_M].get(ENS_ID)
                if not Gene_obj_M:
                    continue

                # Counting all mutational targets lesser than mu2
                mut_targ_P_iter = Gene_obj_P.gene_mu
                if mut_targ_P_iter < top_CH.mu:
                    mut_targ_P = mut_targ_P_iter
                else:
                    mut_targ_P = top_CH.mu

                mut_targ_M_iter = Gene_obj_M.gene_mu
                if mut_targ_M_iter < top_CH.mu:
                    mut_targ_M = mut_targ_M_iter
                else:
                    mut_targ_M = top_CH.mu

                # y, CH_lambda and corr_factor are updated here
                y += np.max([mut_targ_P, mut_targ_M]) ** 2
                corr_factor += np.max([mut_targ_P_iter, mut_targ_M_iter]) ** 2
                CH_lambda += var_num_P * var_num_M * mut_targ_P_iter * mut_targ_M_iter

    # y normalization
    y = y / corr_factor

    # probability of y given CH_lambda
    P_arr = calc_CH_IND_P(y, CH_lambda)

    # Writing the output
    print_CH_IND_line(outh,
                      P_arr,
                      top_CH,
                      top_CH.ENS_ID,
                      ENS2GeneID_dict,
                      first_line=False)

# Written on 01.23.2024 by Mikhail Moldovan, HMS DBMI
